function processRetinaFlashStimDataFN1conditions(clusterFilepath)
%% -------- load data --------
responseQualityThreshold = 0.1;

preSavePath = extractBefore(clusterFilepath, '.');
matSavePath = [preSavePath{:} '.mat'];
load(matSavePath,'data');

responsePath = [preSavePath{:} '_responseMetrics.mat'];
load(responsePath,'responseMetrics');

%% -------- 选出有效神经元（保持你的原逻辑） --------
validNeurons = [];
for i = 1:length(responseMetrics.ISIon_mean)
    if  data.channelNames{6,i} >= 300
        validNeurons = [validNeurons; i]; %#ok<AGROW>
    end
end

numValidClusters = length(validNeurons);
numNeurons = [];
for idx = 1:numValidClusters
    i = validNeurons(idx);
    meanwaveforms = data.waveformClusterMeans(i,:);
    
    % 负峰与正峰
    [invertedPeaks, t0] = findpeaks(-meanwaveforms);
    [~,t1] = max(meanwaveforms);

    if ~isempty(invertedPeaks)
        numNegativeVally = sum(invertedPeaks>0);
        if numNegativeVally == 1 && abs(invertedPeaks(1)) > 1000
            peaktimediff = t1 - t0(1);
            ISI_vio = responseMetrics.ISI_vio(i);
            if peaktimediff > 0 && ISI_vio < 0.05
                numNeurons = [numNeurons; i]; %#ok<AGROW>
            end
        end
    end
end


%% -------- 分类（四个条件） --------
condition_names = {'scotopic','mesopic','photopic','all'};
results = struct([]);

count = 0;

for k = 1:numel(condition_names)
    condName = condition_names{k};

    % 全部初始化为数值矩阵（列向量）
    N = struct();
    N.name = condName;  % 只是个标签，不参与矩阵存储
    N.num_OnNeurons = struct('trans', [], 'sus', []);
    N.num_OffNeurons = struct('trans', [], 'sus', []);
    N.num_OnOffNeurons = [];
    N.num_unconventional = [];
    N.num_notRespond = [];

    for i = 1:numel(numNeurons)
        curCl = numNeurons(i);

        count = count + 1;
        disp(['On ' num2str(count) ' of ' num2str(4*numel(numNeurons))]);

        % 只取分类所需的度量
        clusterResponses.responseQuality  = responseMetrics.responseQuality(curCl,:);
        clusterResponses.BI               = responseMetrics.BI{curCl};
        clusterResponses.TI_on            = responseMetrics.TI_on{curCl};
        clusterResponses.TI_off           = responseMetrics.TI_off{curCl};
        clusterResponses.ratio            = responseMetrics.ratio{curCl};

        rq_max = max(clusterResponses.responseQuality);

        if k ~= 4  % 单条件
            BI_k    = clusterResponses.BI(k);
            ratio_k = clusterResponses.ratio(k);
        else       % "all"：跨条件均值
            BI_k    = mean(clusterResponses.BI,   'omitnan');
            ratio_k = mean(clusterResponses.ratio,'omitnan');
        end

        TIon  = mean(clusterResponses.TI_on,  'omitnan');
        TIoff = mean(clusterResponses.TI_off, 'omitnan');

        % ⚠️ 假设这里拿到的是**数值**ID（如通道号）；若不是数值，请改成数值来源
        ch = data.channelNames{4, curCl};

        % 分类逻辑（保持你的阈值）
        if rq_max > responseQualityThreshold

            if BI_k >= 0.33
                if TIon < 0.1
                    N.num_OnNeurons.trans(end+1,1) = ch;
                else
                    N.num_OnNeurons.sus(end+1,1)   = ch;
                end

            elseif BI_k <= -0.33
                if TIoff <= 0.1
                    N.num_OffNeurons.trans(end+1,1) = ch;
                else
                    N.num_OffNeurons.sus(end+1,1)   = ch;
                end

            elseif (BI_k > -0.33) && (BI_k < 0.33)
                N.num_OnOffNeurons(end+1,1) = ch;

            else
                % ratio 兜底
                if ratio_k >= 2
                    if TIon <= 0.1
                        N.num_OnNeurons.trans(end+1,1) = ch;
                    else
                        N.num_OnNeurons.sus(end+1,1)   = ch;
                    end
                elseif ratio_k <= 0.5
                    if TIoff <= 0.1
                        N.num_OffNeurons.trans(end+1,1) = ch;
                    else
                        N.num_OffNeurons.sus(end+1,1)   = ch;
                    end
                else
                    N.num_unconventional(end+1,1) = ch;
                end
            end

        elseif (rq_max > 0.05) && (rq_max <= responseQualityThreshold)
            N.num_unconventional(end+1,1) = ch;
        else
            N.num_notRespond(end+1,1) = ch;
        end
    end

    % 汇总到一个列向量（数值）
    N.S = [ N.num_OnNeurons.trans; N.num_OnNeurons.sus; ...
            N.num_OffNeurons.trans; N.num_OffNeurons.sus; ...
            N.num_OnOffNeurons; N.num_unconventional; N.num_notRespond ];

    % 计数
    N.counts = [ numel(N.num_OnNeurons.trans); ...
                 numel(N.num_OnNeurons.sus); ...
                 numel(N.num_OffNeurons.trans); ...
                 numel(N.num_OffNeurons.sus); ...
                 numel(N.num_OnOffNeurons); ...
                 numel(N.num_unconventional); ...
                 numel(N.num_notRespond) ];

    results{k} = N; %#ok<SAGROW>
end

% 保存结果（包含四个条件）
save(strcat(preSavePath, "_totalneuronsV3.mat"), 'results');

%% -------- 计算 ON/OFF 的四集合重叠，并绘制 Venn 草图 --------
% 每个条件的 ON / OFF 集合（数值向量）
A_on = unique([results{1}.num_OnNeurons.trans; results{1}.num_OnNeurons.sus]).';
B_on = unique([results{2}.num_OnNeurons.trans; results{2}.num_OnNeurons.sus]).';
C_on = unique([results{3}.num_OnNeurons.trans; results{3}.num_OnNeurons.sus]).';
D_on = unique([results{4}.num_OnNeurons.trans; results{4}.num_OnNeurons.sus]).';

A_off = unique([results{1}.num_OffNeurons.trans; results{1}.num_OffNeurons.sus]).';
B_off = unique([results{2}.num_OffNeurons.trans; results{2}.num_OffNeurons.sus]).';
C_off = unique([results{3}.num_OffNeurons.trans; results{3}.num_OffNeurons.sus]).';
D_off = unique([results{4}.num_OffNeurons.trans; results{4}.num_OffNeurons.sus]).';

onStats  = venn3_region_counts(A_on, B_on, C_on);
offStats = venn3_region_counts(A_off, B_off, C_off);

% 打印（把所有“不重合/部分重合/全重合”区域 + 每个条件总数 + 并集 total 都列出来）
disp('=== ON: 3-condition region counts ===');
print_venn3_stats(onStats, 'A(scotopic)','B(mesopic)','C(photopic)');
disp('=== OFF: 3-condition region counts ===');
print_venn3_stats(offStats,'A(scotopic)','B(mesopic)','C(photopic)');

% 绘图：在 Venn 上标每个区域计数、每个条件总数 (n=)、以及并集 total
figure('Name','ON Venn (3 conditions + totals)');
plotVenn3_with_totals(onStats, 'scotopic','mesopic','photopic', 'ON overlap (3 cond)');

figure('Name','OFF Venn (3 conditions + totals)');
plotVenn3_with_totals(offStats,'scotopic','mesopic','photopic', 'OFF overlap (3 cond)');

end % ===== 主函数结束 =====


%% ===================== 局部函数（全部基于数值矩阵） =====================

function S = venn3_region_counts(A,B,C)
% 输入：A/B/C 为数值向量（行或列）
% 输出：包含 7 区域计数 + 每条件总数 + 并集总数
    A = unique(A(:).'); B = unique(B(:).'); C = unique(C(:).');
    U = unique([A B C]);

    onlyA = setdiff(A, union(B,C));
    onlyB = setdiff(B, union(A,C));
    onlyC = setdiff(C, union(A,B));
    AB    = setdiff(intersect(A,B), C);
    AC    = setdiff(intersect(A,C), B);
    BC    = setdiff(intersect(B,C), A);
    ABC   = intersect(intersect(A,B), C);

    S.count_onlyA = numel(onlyA);
    S.count_onlyB = numel(onlyB);
    S.count_onlyC = numel(onlyC);
    S.count_AB    = numel(AB);
    S.count_AC    = numel(AC);
    S.count_BC    = numel(BC);
    S.count_ABC   = numel(ABC);

    S.total_A = numel(A);
    S.total_B = numel(B);
    S.total_C = numel(C);
    S.total_union = numel(U);

    % 也把集合本身返回（需要时可用）
    S.set_onlyA = onlyA;
    S.set_onlyB = onlyB;
    S.set_onlyC = onlyC;
    S.set_AB    = AB;
    S.set_AC    = AC;
    S.set_BC    = BC;
    S.set_ABC   = ABC;
    S.set_A = A; S.set_B = B; S.set_C = C; S.set_union = U;
end

function print_venn3_stats(S, labA, labB, labC)
    fprintf('%s only: %d\n', labA, S.count_onlyA);
    fprintf('%s only: %d\n', labB, S.count_onlyB);
    fprintf('%s only: %d\n', labC, S.count_onlyC);
    fprintf('%s & %s only: %d\n', labA, labB, S.count_AB);
    fprintf('%s & %s only: %d\n', labA, labC, S.count_AC);
    fprintf('%s & %s only: %d\n', labB, labC, S.count_BC);
    fprintf('%s & %s & %s: %d\n', labA, labB, labC, S.count_ABC);
    fprintf('Total %s: %d, %s: %d, %s: %d\n', labA, S.total_A, labB, S.total_B, labC, S.total_C);
    fprintf('Union total (A | B | C): %d\n\n', S.total_union);
end

function plotVenn3_with_totals(S, labelA, labelB, labelC, titleStr)
% 画 3 圆 Venn（拓扑图）：标 7 区域计数 + 每条件总数 (n=) + 并集 total
    hold on; axis equal off;

    r = 2.3; th = linspace(0,2*pi,400);
    ctr = [-1.5, 0; 1.5, 0; 0, 1.5]; % A 左, B 右, C 上

    % 圆
    for i=1:3
        plot(ctr(i,1)+r*cos(th), ctr(i,2)+r*sin(th), 'LineWidth',1.5);
    end
    title(sprintf('%s | union total = %d', titleStr, S.total_union));

    % 标签 + 每条件总数
    text(ctr(1,1)-0.2, ctr(1,2)-r-0.5, sprintf('%s (n=%d)', labelA, S.total_A), ...
        'HorizontalAlignment','center','FontWeight','bold');
    text(ctr(2,1)+0.2, ctr(2,2)-r-0.5, sprintf('%s (n=%d)', labelB, S.total_B), ...
        'HorizontalAlignment','center','FontWeight','bold');
    text(ctr(3,1), ctr(3,2)+r+0.6, sprintf('%s (n=%d)', labelC, S.total_C), ...
        'HorizontalAlignment','center','FontWeight','bold');

    % 7 区域数值（仅 A/B/C，AB/AC/BC only，ABC）
    % 位置手动调优，清晰可读
    text(-3.1, 0.0, num2str(S.count_onlyA), 'HorizontalAlignment','center');   % only A
    text( 3.1, 0.0, num2str(S.count_onlyB), 'HorizontalAlignment','center');   % only B
    text( 0.0, 3.0, num2str(S.count_onlyC), 'HorizontalAlignment','center');   % only C

    text( 0.0, 0.8, num2str(S.count_AB),  'HorizontalAlignment','center');     % AB only
    text(-0.9, 1.0, num2str(S.count_AC),  'HorizontalAlignment','center');     % AC only
    text( 0.9, 1.0, num2str(S.count_BC),  'HorizontalAlignment','center');     % BC only

    text( 0.0, 0.2, num2str(S.count_ABC), 'HorizontalAlignment','center');     % ABC

    hold off;
end
